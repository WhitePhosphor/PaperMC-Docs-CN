---
title: 概述
description: 关于 Folia 工作原理的概述。
slug: folia/reference/overview
---

本文档描述了 Folia 所做的更改的抽象概述。
Folia 将所有已加载世界中的区块划分为独立计时的区域，以便这些区域可以独立且并行地进行计时。
首先描述的是区域内操作，然后是区域间操作。

## 独立区域的规则

为了确保区域的独立性，维护区域的规则必须确保一个正在运行的区域没有直接相邻的正在运行的邻近区域。
以下规则保证了不变量的维护：
1. 任何正在运行的区域在运行期间不能增长。
2. 任何正在运行的区域最初必须在其周边拥有一定数量的区块缓冲区。
3. 如果有相邻的邻近区域，区域则不能 _开始_ 运行。
4. 相邻的区域最终必须合并成一个区域。

此外，为了确保一个区域不是由独立区域组成的（这将阻碍并行性），由多个独立区域组成的区域必须在可能的情况下最终被拆分成独立的区域。

最后，为了确保运行的区域可以存储和维护有关当前区域的数据（例如，运行次数、区域内的实体、区域内的区块、方块/流体运行列表等），区域有自己的数据对象，该对象只能在运行区域时由运行该区域的线程访问。
此外，还有合并或拆分区域的回调，以便适当更新数据对象。

这些规则的实现描述在 [区域逻辑](/folia/reference/region-logic) 中。

应用这些规则的最终结果是，一个正在运行的区域可以确保只有当前线程对区域内包含的任何数据具有写访问权限，并且在任何给定时间，独立区域的数量接近最大值。

## 区域内操作

区域内操作是指只处理单个区域数据的操作，由拥有该区域的区域执行，或者涉及合并/拆分逻辑。

### 独立区域的运行

独立区域独立且并行地运行。
独立运行意味着区域维护自己的下一个运行的截止时间。
例如，考虑两个区域 A 和 B，A 的下一个运行开始时间是 t=15ms，B 的下一个运行开始时间是 t=0ms。
考虑以下事件序列：
1. 在 t=0ms 时，B 开始运行。
2. 在 t=15ms 时，A 开始运行。
3. 在 t=20ms 时，B 完成了它的运行。然后它被安排在 t=50ms 时再次运行。
4. 在 t=50ms 时，B 开始它的第二次运行。
5. 在 t=70ms 时，B 完成了它的第二次运行，并被安排在 t=100ms 时再次运行。
6. 在 t=95ms 时，A 完成了它的 _第一次_ 运行。它被安排在 t=95ms 时再次运行。

需要注意的是，B 的运行计划从未受到 A 未能达到 20TPS 目标的影响。

为了实现上述行为，每个区域都在计划执行器（参见 `SchedulerThreadPool`）上维护一个重复任务，该任务根据最早开始时间优先的调度算法安排任务。
该算法类似于 EDF，但根据开始时间进行调度。
然而，考虑到每个运行的截止时间是 50ms + 开始时间，它的行为与 EDF 算法完全相同。

选择这种类似 EDF 的算法是为了确保只要线程池没有被充分利用，所有运行时间 <= 50ms 的区域都将保持 20TPS。
然而，这种调度算法既不是 NUMA 感知的，也不是 CPU 核心感知的——它不会尝试（当 n 个区域 > m 个线程时）将区域固定到某些核心上。

由于区域独立运行，每个区域都有它们维护自己的 Tick 计数器。
这一事实的含义将在下一部分中描述。

### Tick 计数器

在标准原版游戏中，有几个重要的运行计数器：当前运行次数、游戏时间运行次数和白天时间运行次数。
当前运行次数用于确定服务器启动以来的运行次数。
游戏时间运行次数是按世界维护的，用于安排红石、流体和其他物理事件的方块运行。
白天时间运行次数仅仅是自中午以来的运行次数，按世界维护。

在 Folia 中，当前运行次数是按区域维护的。
游戏时间运行次数被拆分为两个计数器：红石时间和全局游戏时间。
红石时间是按区域维护的。
全局游戏时间和白天时间由“全局区域”维护。

在每个区域运行开始时，全局游戏时间运行次数和白天时间运行次数从全局区域复制过来，当前区域在运行期间检索这些值时，将从运行开始时收到的副本中检索。
这是为了确保在运行期间的任何两次检索运行次数的调用，这两次调用报告相同的运行次数。

维护全局游戏时间的原因有几个：
1. 需要一个计数器来表示一个世界已经存在了多少个运行次数，因为游戏确实会跟踪世界已经持续的总天数。
2. 大量新的实体 AI 代码使用游戏时间（出于我无法理解的原因）来存储任务的绝对截止时间。
   虽然编写代码来调整所有这些任务的截止时间并非不可能，但工作量相当大。

#### 全局区域

全局区域是一个始终以 20TPS 运行的计划任务，负责维护不特定于任何区域的数据：游戏规则、全局游戏时间、白天时间、控制台命令处理、世界边界、天气等。
与其他区域不同，全局区域不需要执行任何合并或拆分的特殊逻辑，因为它永远不会被拆分或合并——任何时候只有一个全局区域。
全局区域不拥有任何区域特定的数据。

#### 合并和拆分区域运行时间

由于红石和当前运行次数是按区域维护的，因此需要适当的逻辑来调整方块/流体运行调度器和其他任何按红石/当前绝对运行次数安排的任务所使用的运行截止时间，以确保相对截止时间不受影响。

当将区域 x（从）合并到区域 y（到）时，我们可以调整 x 和 y 的截止时间，或者只调整 x 或 y 中的一个。
只调整一个会更简单，而 x 被任意选择。
然后，必须调整 x 的截止时间，以便在考虑 y 的当前运行次数时，相对截止时间保持不变。

考虑一个截止时间 d1 = 从运行次数 + 区域 x 中的相对截止时间。
然后，我们希望调整后的截止时间 d2 为 d2 = 到运行次数 + 区域 y 中的相对截止时间，以便保持相对运行截止时间。
我们可以通过应用一个偏移量 o 到 d1 来实现这一点，使得 d1 + o = d2，使用的偏移量是 o = 到运行次数 - 从运行次数。
由于增加红石运行次数的逻辑可以通过 `Level#tickTime` 字段关闭，因此必须分别计算红石运行次数和当前运行次数的偏移量。

最后，拆分的情况很简单——当发生拆分时，拆分后的独立区域从父区域继承红石/当前运行次数。
因此，相对截止时间得以保持，因为没有运行次数的变化。

在所有情况下，当区域拆分或合并时，红石或任何其他按当前运行次数安排的事件都保持不变，因为在合并情况下通过应用偏移量来保持相对截止时间，在拆分情况下通过复制运行次数来保持。

## 区域间操作

区域间操作是指与当前运行区域之外的其他区域进行操作，这些区域可能处于完全未知的状态。
这些区域可能是过渡的，可能是正在运行的，甚至可能根本不存在。

### 辅助操作的工具

为了协助区域间操作，提供了几种工具。
在NMS中，这些工具是 `EntityScheduler`、`RegionizedTaskQueue`、全局区域任务队列和区域本地数据提供者 `RegionizedData`。
Folia API 有类似的类似物，但没有区域本地数据提供者，因为 NMS 数据提供者持有关键锁，
并且在执行任何回调逻辑时在代码的关键部分被调用，因此非常容易受到涉及长时间 I/O 或世界状态修改的致命插件错误的影响。

#### `EntityScheduler`

`EntityScheduler` 允许安排任务在拥有该实体的区域上执行。
这在处理实体传送时特别有用，因为一旦实体开始异步传送，该实体在传送完成之前不能运行，而且时间是不确定的。

#### `RegionizedTaskQueue`

`RegionizedTaskQueue` 允许安排任务在拥有特定位置的区域的下一个运行中执行，或者如果该区域不存在，则创建这样的区域。
这对于可能需要在当前区域之外编辑或检索世界/方块/区块数据的任务很有用。

#### 全局区域任务队列

全局区域任务队列只是用于对全局区域拥有的数据进行编辑，例如游戏规则、白天时间、天气，或者使用控制台命令发送者执行命令。

#### `RegionizedData`

`RegionizedData` 类允许区域定义区域本地数据，从而允许区域存储数据而无需考虑来自其他区域的并发数据访问。
例如，每个区域的当前实体/区块/方块/流体运行列表得以维护，这样区域就不需要考虑对这些数据集的并发访问。

这些工具允许以简单的方式解决各种跨区域问题，例如通过使用任务队列从任何区域编辑方块/实体/世界状态，或者通过使用 `RegionizedData` 避免并发问题。
更高级的操作，如传送、玩家重生和传送门传送，都利用这些工具来确保操作是线程安全的。

### 实体内区域和跨区域传送

为了在其他区域或维度之间安全地传送实体，需要特殊的逻辑。
然而，在所有情况下，传送/放置实体的调用必须在拥有该实体的区域上进行。
可以使用 `EntityScheduler` 轻松地安排在这样的上下文中执行代码。

#### 简单传送

在简单的传送中，实体已经存在于世界中的某个位置，并且目标位置和维度是已知的。
这个操作分为两个部分：转换和异步放置。
在这种情况下，转换操作将实体从当前世界中移除，然后调整位置。
异步放置操作使用 `RegionizedTaskQueue` 安排一个任务到目标位置，将实体添加到目标维度的目标位置。

各种实现细节，例如在转换操作中非玩家实体被复制，被省略了，因为这些与高级概述无关。

玩家登录和玩家重生通常被认为是简单的传送。
玩家登录的情况有所不同，因为玩家在开始时不存在于任何世界中，并且异步转换还必须找到一个地方来生成玩家。
玩家重生与玩家登录类似，因为重生时玩家已经存在于世界中。

#### 传送门传送

传送门传送与简单传送不同，因为传送门传送 **_不知道_** 传送的确切位置。
因此，转换步骤不会更新实体位置，而是插入了一个新的操作在转换和异步放置之间：异步搜索/创建，它负责寻找和/或创建出口传送门。

此外，当前的原版代码如果实体是非玩家且下界出口传送门不存在，可能会拒绝传送。
但由于传送门的位置只在异步放置时确定，此时取消已经太晚了——因此，传送门逻辑已经被重新设计，使得玩家和实体之间没有区别。
现在，无论是玩家还是实体，无论是下界还是末地，都会创建出口传送门。

#### 传送期间关闭

由于传送是分多个步骤进行的，服务器关闭过程必须手动处理未完成的传送。

## 服务器关闭过程

关闭过程通过启动一个单独的关闭线程来完成，该线程随后运行关闭逻辑：
1. 关闭运行区域调度器，停止任何进一步的运行。
2. 停止指标处理。
3. 禁用插件。
4. 停止接受新的连接。
5. 向所有玩家发送断开连接（但不移除）的数据包。
6. 停止所有世界中的区块系统。
7. 通过完成所有区域的所有待处理传送，然后保存世界中的所有区块，最后保存世界的数据（level.dat 和其他 .dat 文件），为所有世界执行关闭逻辑。
8. 保存所有玩家。
9. 关闭资源管理器。
10. 释放级别锁。
11. 停止剩余的执行器（Util 执行器、区域 I/O 线程等）。


与原版游戏的重要区别在于，玩家踢出和世界保存逻辑被替换为步骤 5-8。

对于步骤 5，玩家不能在传送完成之前被踢出，因为踢出会保存玩家数据文件。
因此，保存操作被移到后面。

对于步骤 6，在保存之前停止区块系统，以便停止所有区块生成。
这将在服务器关闭时减少服务器的负载，这在内存受限的情况下可能至关重要。

对于步骤 7，传送的完成方式取决于类型：简单传送或传送门传送。

简单传送通过确保传送的实体被添加到传送指定的目标区块中来完成。
这使得实体可以在目标位置被保存，就好像传送在关闭之前已经完成一样。

传送门传送通过强制将传送的实体添加到源区块中来完成，实体本应从该区块传送 **_出去_** 。
由于目标位置未知，实体只能被放回原点（不进行传送）。
虽然这种行为并不理想，但关闭逻辑 **_必须_** 考虑任何损坏的世界状态——这意味着寻找或创建目标出口传送门可能不是一个选项。

传送完成必须在世界保存之前进行，以便传送完成的实体得以保存。

对于步骤 8，在传送完成之后再保存玩家。

其余步骤与原版游戏一致。
